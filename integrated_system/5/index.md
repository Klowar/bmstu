# Оптимизации

## Оптимизации циклов

1. Развертывание циклов (unrolling)
```
int sum = 0
for(i = 0; i < N; i++)
    sum = sum + a[i]
```
### Неоптемизированный случай
тело цикла - 4 такта
```
ld R2, @R5 # загрузить данные из регистра R5 данные в регистр R2
add R4, R2, R4 #  Сложить в регистр R4 сумму значений из регистра R2, R4
inc R5
```
управление циклом - 5 тактов
```
inc R3
cmp R3, R7
jge out
jmp start
```
### Unrolling (развертывание циклов)

```
int lenglong, lenshort;
lenlong = N / 4;
lenshort = N % 4;
sum = 0;
for(i = 0; i < lenlong; i++) {
    sum = sum + a[i * 4];
    sum = sum + a[i * 4 + 1];
    sum = sum + a[i * 4 + 2];
    sum = sum + a[i * 4 + 3];
}
# остаток от развертывания
for(i = 0; i < lenshort; i++)
    sum = sum + a[lenlong * 4 + 1];
```
4 - глубина развертывания
5 тактов на управление
16 тактов на вычисление
21 такт - итерация цикла

при достаточно длинным массиве можно принебречь остатком развертывания

Оптимизации деления, на которую расчитывают при использовании unrolling
N / 4 - N >> 2
N % 4 - N & 0x3

Условия для применения оптимизации:
1. простая базовая итерация
2. для больших массивов
3. развертывание не для N = 2**k
4. может потребоваться выравнивание массива по (страницам, строкам кеша etc)
5. прагмы расчитывающие определенные минимальное и максимальное кол-во элементов

### Loop pipelining (конверизация циклов)

Применяется для VLIW и суперскаляров

```
for(i = 0; i < N; i++) {
    A[i] = ....
    B[i] = A[i]...
}
```
имеется зависимость по данным

```
A[0] = ... # Пролог

for(i = 0; i < (N - 1); i++) {
    A[i + 1] = ...
    B[i] = A[i] ....
}

B[N - 1] = A[N - 1]+.... # Эпилог
```

### Loop invariant code motion (Вынос инвариантного кода из тела цикла)

```
for(...) {
    a[i] = koef/def * b[i];
} 
```

```
K = koef / def;
for(...) {
    a[i] = K * b[i];
} 
```

### Loop reversal (Обращение цикла)

```
for(i = 0; i < N; i++)
```
```
for(i = N; i != 0; i--)
```
Сравнение с нулем проще, чем сравнение с N:
51: djnz инструкция

RISC:
R0 - генератор константного 0

### Induction variables (Переменные индукции)
induction variable - переменная, которая при последовательных итерациях изменяются на константу
```
for(i...) {
    ...
    k = i * 5; 
    ...
}
```
```
for(i...) {
    ...
    k = k + 5;
    ...
}
```
применяетя, если операцию умножения сложнее операции сложения
```
ld R8, 4
mul R8, R3, R5
ld R7, @a[0]
add R7, R5, R7
```
```
add R7, R8, R7
```

### (Вынос условного оператора и оператора выбора из тела цикла)
```
for(...) {
    if (...) { # Не зависищее от итерации цикла условие

    }
}
```
```
    if (...)
        for(...) {}
    else
        for(...) {}
```
Аналогично для switch

### Loop inversion (Инверсия цикла)

```
while (i < N) {
    ....
}
```
1) Сравнение i и N
2) Тело
3) Переход в начало
...
k-1) Сравнение i и N # false
k) выход из цикла
k+1) продолжение выполнения
```
if (i != 0) {
    do {
        ...
    } while (i < N)
}
```
1) Сравнение i и 0
2) Тело
3) Сравнение i и N
4) Переход в начало
...
k-1) Сравнение i и N
k) продолжение выполнения

Оптимизация должна быть использована вместе с предсказанием ветвления
