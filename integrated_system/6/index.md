# Оптимизация кода

Способы оптимизации
- Размещение данных (Выравнивание, встроеные модули памяти)
- Оптимизация кода
  - Ручная
  - Компилятора

Наборы оптимизаций включаемые наборы опций:
- О0 ---|---|----|
- О1____|   |    |
- О2________|    |
- О3_____________| (быстродействие)

Отлаживать программу нужно на оптимизация уровня 0-1
Начиная с О2 становится тяжело отлаживать из-за нечитаемости ассемблера

## Выравнивание памяти

```
unsigned char a;
unsigned int b;
```
а будет размещен на границы текущего слова
char - 8бит
int - 32бит
 ___
| a |
|   |
|   |
|___|
|=b=|
|===|
|===|
|===|
b - занимает данные полностью, a - оставляет пустые данные
Для оптимизации - объявлять сначала переменные от большего типа к меньшему
Для отображения структуры на область памяти она должна быть объявлена как упакованная

## Про типы

Лучше всего всегда использовать типы с указанной разрядностью
```
int8s
int8u
...
```
Для вспомогательных переменных лучше использовать переменные разрядности процессора

## Ручные оптимизации

- inline (не вызывать функцию, а вставить код функции в место ее использования)
- switch (оптимизации операторов выбора)
  + наиболее частые ответы перенести в начало
  + массив из указателей на фукнции и вызывать их по индексу
- Предподсчитанные таблицы
- реализовать некоторый код на ассемблере
  - в отдельную функцию
  - calling conventions
  * не делать без жесткой надобности

# Оптимизации компилятора

- Локальные
  - peep hole:
    ```
        mov r2,r5 
        mov r4,r2          ->  mov r4, r5
    ```
- На уровне фукнций
  - оптимизация На уровне назначения регистров
  - оптимизация циклов
- Глобальные  (уровень файла)
  - inline
  - cross call

Примеры оптимизаций:
- Register
- Common subexpression elimination
- Strenght reduction
