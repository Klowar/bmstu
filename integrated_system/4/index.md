# Лекция 3

## Суперпетля

приложение явялется бесконечным циклом

void main() {
    int_vars();
    int_periph();
    while(1) {
        process_key();
        process_sensors();
        ...
    }
}

для снижения энергопотребления после итерации цикла можно ввести процессор в низкопотребляющий режим

- Асинхронные события обрабатываютс ISR(уровень прерываний).
- Фоновые задачи выполняются в фиксированном порядке по необходимости.
- максимальное время цикла - время открилка уровня задач (фона).
- нет механизмов обмена данными между процессами

Обычно имеется:
- обработчик прерываний
- прерывание таймера (мультиплексный обработчик)
- петля

### Мультиплексный обработчик

void ITL0(void) interrupt 1 using 1
{
    ...
}

void iSerial(void) interrupt 4 using 3
{
    ...
}

для обхода проблемы наложения одного прерывания на другое делается сдвиг по времени

__|---|______|---|_____

--|______|--|____
_______|-|_______|-|

### Передача данных

Для передачи данных используются общие переменные
__volatile__ переменные в C

### Оценка

+ Не требует ядра OC
+ не требует памяти для сохранения контекста

- Растет время открилка
- Время цикла недетерменированно
- Сложность модификаций из-за связности
- Механизм обмена информации определяется разработчиком

* применяетс ядля реализации простых систем
* требует точного расчета карты времени

# Подготовка к РК

0. Сформулировать требования
1. Изучить документацию периферийного модуля (+errata)
   1. определяем в каком режиме модуль должен работать
   2. определить значения регистров для настройки 
      1. Инициализации
      2. Управление переферийным модулем при фукнционировании
2. Определить последовательность инициализации
3. функция инициализации
4. фукнция управления
   1. определить механизмы обмена данными с уровнем приложения и с аппаратурой
   2. реализовать механизмы обмена данными с уровнем приложения и с аппаратурой
      1. по опросу
      2. по прерыванию
      3. с использованием ПДП

ПДП (для архитектур с кэшем):
-> {
    write_data()
    cache_flush(a, sizeof(a));
    start_data_tx(a, sizeof(a));
}
<- {
    cache_invalidate(a, sizeof(a));
    process_data(a);
}

